/*
   This file was generated automatically by Alchitry Labs version 1.2.1.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module control_1 (
    input clk,
    input rst,
    input write_b,
    input auto,
    input [15:0] in,
    input [5:0] alufn,
    output reg [15:0] out,
    output reg z,
    output reg v,
    output reg n,
    output reg alufnexception
  );
  
  
  
  reg [5:0] alufn_IN;
  
  wire [16-1:0] M_adder16bit_s;
  wire [1-1:0] M_adder16bit_z;
  wire [1-1:0] M_adder16bit_v;
  wire [1-1:0] M_adder16bit_n;
  reg [16-1:0] M_adder16bit_a;
  reg [16-1:0] M_adder16bit_b;
  reg [1-1:0] M_adder16bit_alufn0;
  adder16bit_3 adder16bit (
    .a(M_adder16bit_a),
    .b(M_adder16bit_b),
    .alufn0(M_adder16bit_alufn0),
    .s(M_adder16bit_s),
    .z(M_adder16bit_z),
    .v(M_adder16bit_v),
    .n(M_adder16bit_n)
  );
  
  wire [16-1:0] M_comp16bit_out;
  reg [1-1:0] M_comp16bit_z;
  reg [1-1:0] M_comp16bit_v;
  reg [1-1:0] M_comp16bit_n;
  reg [2-1:0] M_comp16bit_alufn;
  comp16bit_4 comp16bit (
    .z(M_comp16bit_z),
    .v(M_comp16bit_v),
    .n(M_comp16bit_n),
    .alufn(M_comp16bit_alufn),
    .out(M_comp16bit_out)
  );
  
  wire [16-1:0] M_mult16bit_out;
  reg [16-1:0] M_mult16bit_a;
  reg [16-1:0] M_mult16bit_b;
  mult16bit_5 mult16bit (
    .a(M_mult16bit_a),
    .b(M_mult16bit_b),
    .out(M_mult16bit_out)
  );
  
  wire [16-1:0] M_shifter_s;
  reg [16-1:0] M_shifter_a;
  reg [4-1:0] M_shifter_b;
  reg [2-1:0] M_shifter_alufn;
  shifter_6 shifter (
    .a(M_shifter_a),
    .b(M_shifter_b),
    .alufn(M_shifter_alufn),
    .s(M_shifter_s)
  );
  
  wire [16-1:0] M_boolean_s;
  reg [16-1:0] M_boolean_a;
  reg [16-1:0] M_boolean_b;
  reg [4-1:0] M_boolean_alufn;
  boolean_7 boolean (
    .a(M_boolean_a),
    .b(M_boolean_b),
    .alufn(M_boolean_alufn),
    .s(M_boolean_s)
  );
  
  wire [16-1:0] M_divider_quotient;
  wire [16-1:0] M_divider_remainder;
  reg [16-1:0] M_divider_a;
  reg [16-1:0] M_divider_b;
  divider_8 divider (
    .a(M_divider_a),
    .b(M_divider_b),
    .quotient(M_divider_quotient),
    .remainder(M_divider_remainder)
  );
  
  reg [15:0] M_register_a_d, M_register_a_q = 1'h0;
  
  reg [15:0] M_register_b_d, M_register_b_q = 1'h0;
  
  wire [1-1:0] M_butcon_out;
  reg [1-1:0] M_butcon_in;
  button_conditioner_9 butcon (
    .clk(clk),
    .in(M_butcon_in),
    .out(M_butcon_out)
  );
  
  wire [1-1:0] M_butrise_out;
  reg [1-1:0] M_butrise_in;
  edge_detector_10 butrise (
    .clk(clk),
    .in(M_butrise_in),
    .out(M_butrise_out)
  );
  
  
  localparam SOFF_auto_toggle = 1'd0;
  localparam SON_auto_toggle = 1'd1;
  
  reg M_auto_toggle_d, M_auto_toggle_q = SOFF_auto_toggle;
  
  wire [6-1:0] M_fsmcontrol_alufn;
  wire [16-1:0] M_fsmcontrol_fsma;
  wire [16-1:0] M_fsmcontrol_fsmb;
  reg [1-1:0] M_fsmcontrol_run;
  fsmcontrol_11 fsmcontrol (
    .clk(clk),
    .rst(rst),
    .run(M_fsmcontrol_run),
    .alufn(M_fsmcontrol_alufn),
    .fsma(M_fsmcontrol_fsma),
    .fsmb(M_fsmcontrol_fsmb)
  );
  
  always @* begin
    M_auto_toggle_d = M_auto_toggle_q;
    M_register_b_d = M_register_b_q;
    M_register_a_d = M_register_a_q;
    
    M_butcon_in = auto;
    M_butrise_in = M_butcon_out;
    
    case (M_auto_toggle_q)
      SOFF_auto_toggle: begin
        M_fsmcontrol_run = 1'h0;
        if (M_butrise_out == 1'h1) begin
          M_auto_toggle_d = SON_auto_toggle;
        end
      end
      SON_auto_toggle: begin
        M_fsmcontrol_run = 1'h1;
        if (M_butrise_out == 1'h1) begin
          M_auto_toggle_d = SOFF_auto_toggle;
        end
      end
      default: begin
        M_fsmcontrol_run = 1'h0;
      end
    endcase
    if (M_auto_toggle_q == 1'h0) begin
      alufn_IN = alufn;
      if (write_b == 1'h0) begin
        M_register_a_d = in;
      end else begin
        M_register_b_d = in;
      end
    end else begin
      alufn_IN = M_fsmcontrol_alufn;
      M_register_a_d = M_fsmcontrol_fsma;
      M_register_b_d = M_fsmcontrol_fsmb;
    end
    M_adder16bit_a = M_register_a_q;
    M_adder16bit_b = M_register_b_q;
    M_adder16bit_alufn0 = alufn_IN[0+0-:1];
    M_comp16bit_z = M_adder16bit_z;
    M_comp16bit_v = M_adder16bit_v;
    M_comp16bit_n = M_adder16bit_n;
    M_comp16bit_alufn = alufn_IN[1+1-:2];
    M_shifter_a = M_register_a_q;
    M_shifter_b = M_register_b_q[0+3-:4];
    M_shifter_alufn = alufn_IN[0+1-:2];
    M_boolean_a = M_register_a_q;
    M_boolean_b = M_register_b_q;
    M_boolean_alufn = alufn_IN[0+3-:4];
    M_mult16bit_a = M_register_a_q;
    M_mult16bit_b = M_register_b_q;
    M_divider_a = M_register_a_q;
    M_divider_b = M_register_b_q;
    z = M_adder16bit_z;
    v = M_adder16bit_v;
    n = M_adder16bit_n;
    
    case (alufn_IN[0+5-:6])
      6'h00: begin
        out = M_adder16bit_s;
        alufnexception = 1'h0;
      end
      6'h01: begin
        out = M_adder16bit_s;
        alufnexception = 1'h0;
      end
      6'h02: begin
        out = M_mult16bit_out;
        alufnexception = 1'h0;
      end
      6'h04: begin
        out = M_divider_quotient;
        alufnexception = 1'h0;
      end
      6'h06: begin
        out = M_divider_remainder;
        alufnexception = 1'h0;
      end
      6'h33: begin
        out = M_comp16bit_out;
        alufnexception = 1'h0;
      end
      6'h35: begin
        out = M_comp16bit_out;
        alufnexception = 1'h0;
      end
      6'h37: begin
        out = M_comp16bit_out;
        alufnexception = 1'h0;
      end
      6'h20: begin
        out = M_shifter_s;
        alufnexception = 1'h0;
      end
      6'h21: begin
        out = M_shifter_s;
        alufnexception = 1'h0;
      end
      6'h23: begin
        out = M_shifter_s;
        alufnexception = 1'h0;
      end
      6'h10: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h11: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h12: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h13: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h14: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h15: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h16: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h17: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h18: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h19: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h1a: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h1b: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h1c: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h1d: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h1e: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      6'h1f: begin
        out = M_boolean_s;
        alufnexception = 1'h0;
      end
      default: begin
        out = 16'h0000;
        alufnexception = 1'h1;
      end
    endcase
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_register_a_q <= 1'h0;
    end else begin
      M_register_a_q <= M_register_a_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_register_b_q <= 1'h0;
    end else begin
      M_register_b_q <= M_register_b_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_auto_toggle_q <= 1'h0;
    end else begin
      M_auto_toggle_q <= M_auto_toggle_d;
    end
  end
  
endmodule
